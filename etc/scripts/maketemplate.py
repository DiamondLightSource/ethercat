#!/bin/env dls-python

# need system python for libxml2 support with xpath

import libxml2
import sys

reqs = set()
base = None
verbose = False

def parseInt(text):
    if text.startswith("#x") or text.startswith("0x"):
        return int(text.replace("#x", ""), 16)
    else:
        return int(text)
macro_header = """
# template generated by maketemplate.py 
# from XML files at %(base)s
# for device %(devtype)s revision %(revision)s 
# non-default pdo assignments: %(extrapdos)s
#
# %% macro, DEVICE, device name
# %% macro, PORT,   asyn port for device
# %% macro, SCAN,   scan rate
"""
longin_text = """
record(longin, "$(DEVICE):%(name)s")
{
  field("DTYP", "asynInt32")
  field("INP",  "@asyn($(PORT))%(command)s")
  field("SCAN", "$(SCAN)")
}
"""

al_text = """
record(mbbi, "$(DEVICE):%(name)s")
{
  field("DTYP", "asynInt32")
  field("INP",  "@asyn($(PORT))%(command)s")
  field("SCAN", "$(SCAN)")
  field("ONVL", "1")
  field("TWVL", "2")
  field("THVL", "4")
  field("FRVL", "8")
  field("ONST", "INIT")
  field("TWST", "PREOP")
  field("THST", "SAFEOP")
  field("FRST", "OP")
}
"""

longout_text = """
record(longout, "$(DEVICE):%(name)s")
{
  field("DTYP", "asynInt32")
  field("OUT",  "@asyn($(PORT))%(command)s")
  field("OMSL", "supervisory")
}
"""
bi_text = """
record(bi, "$(DEVICE):%(name)s")
{
  field("DTYP", "asynInt32")
  field("INP",  "@asyn($(PORT))%(command)s")
  field("SCAN", "$(SCAN)")
  field("ZNAM", "OFF")
  field("ONAM", "ON")
}
"""
bo_text = """
record(bo, "$(DEVICE):%(name)s")
{
  field("DTYP", "asynInt32")
  field("OUT",  "@asyn($(PORT))%(command)s")
  field("OMSL", "supervisory")
  field("ZNAM", "OFF")
  field("ONAM", "ON")
}
"""
ai_text = """
record(ai, "$(DEVICE):%(name)s")
{
  field("DTYP", "asynFloat64")
  field("INP",  "@asyn($(PORT))%(command)s")
  field("SCAN", "$(SCAN)")
}
"""
def shortenname(name):
    "map long names to short"
    map = { "AIINPUTSCHANNEL" : "INPUT",
            "RTDINPUTSCHANNEL": "INPUT",
            "TCTCINPUTSCHANNEL" : "INPUT",
            "TCINPUTSCHANNEL": "INPUT",
            "AISTANDARDCHANNEL" : "INPUT",
            "RTDRTDINPUTSCHANNEL": "INPUT",
            "STATUS__LIMIT" : "SLIMIT",
            "AOOUTPUTSCHANNEL": "OUTPUT",
            "AOOUTPUTCHANNEL": "OUTPUT",
            "ANALOGOUTPUT": "ANALOG",
            "STATUS__UNDERRANGE" : "SUNDERRANGE",
            "STATUS__OVERRANGE" : "SOVERRANGE",
            "STATUS__SYNCERROR": "SSYNCERROR",
            "STATUS__ERROR" : "SERROR",
            "STATUS__TXPDOSTATE": "STXPDOSTATE",
            "STATUS__TXPDOTOGGLE": "STXPDOTOGGLE",
            "STATUS__OUTPUTFUNCTIONSENABLED": "ENABLED",
            "STATUS__STATUSOFOUTPUT": "SOUTPUT",
            "STATUS__SETCOUNTERDONE": "DONE",
            "STATUS__STATUSOFINPUTCLOCK": "SINPUTCLOCK",
            "CNTOUTPUTS:SETCOUNTERVALUE": "CNTOUTPUTS:SET",
            "CNTOUTPUTS:CONTROL__ENABLEOUTPUTFUNCTIONS" : "CNTOUTPUTS:ENABLE",           
            "CNTINPUTS:STATUS__COUNTERINHIBITED": "CNTINPUTS:INHIBITED",
            "CNTINPUTS:STATUS__STATUSOFINPUTUD" : "CNTINPUTS:SINPUTUD",
            "CNTOUTPUTS:CONTROL__ENABLEOUTPUTFUNCTIONS": "CNTOUTPUTS:ENABLE",
            "CNTOUTPUTS:CONTROL__SETOUTPUT" : "CNTOUTPUTS:CSETOUTPUT",
            "CNTOUTPUTS:CONTROL__SETCOUNTER" : "CNTOUTPUTS:CSETCOUNTER",
            "CNTOUTPUTS:CONTROL__INHIBITCOUNTER" : "CNTOUTPUTS:INHIBIT" ,
            "STARTTIMENEXTOUTPUT:STARTTIMENEXTOUTPUT" : "STARTTIMENEXTOUTPUT",
            "CH1CYCLECOUNT:CH1CYCLECOUNT" : "CH1CYCLECOUNT",
            "CH2CYCLECOUNT:CH2CYCLECOUNT" : "CH2CYCLECOUNT", 
            "NEXTSYNC1TIME:STARTTIMENEXTLATCH" :  "NEXTSYNC1TIME",
            }
    short = name.upper()
    count = 0
    print count,  short
    for key in map:
        count = count + 1
        if short.find(key) > -1:
            short = short.replace(key,map[key])
            print count, short
    return short

def fixname(name):
    "make name conventional"
    return shortenname(name.replace(".", ":")).upper()

    
def makeTemplate(ai, longin, longout, bi, bo, output, base, devtype, revision, extraPdos):
    print "Generating template file %s" % output
    f = file(output, "w")
    if len(extraPdos) == 0:
        pdolist = "None"
    else:
        pdolist = ""
    for pdo in extraPdos:
        pdolist = pdolist + "0x%x," % pdo 

    print >> f, macro_header % { "base":        base , 
                                 "devtype":     devtype, 
                                 "revision":    hex(revision),
                                 "extrapdos":   pdolist}
    for l in ["AL_STATE"]:
        print >> f, al_text % {"name": fixname(l), "command": l}
    for l in ["ERROR_FLAG"]:
        print >> f, longin_text % {"name": fixname(l), "command": l}
    for l in longin:
        print >> f, longin_text % {"name": fixname(l), "command": l}
    for l in bi:
        print >> f, bi_text % {"name": fixname(l), "command": l}
    for l in longout:
        print >> f, longout_text % {"name": fixname(l), "command": l}
    for l in bo:
        print >> f, bo_text % {"name": fixname(l), "command": l}
    for l in ai:
        print >> f, ai_text % {"name": fixname(l), "command": l}
    f.close()

def getPdoName(node):
    name = node.xpathEval("Name")[0].content
    name = name.replace(" ", "")
    return name

def getPdoIndex(node):
    indexstr = node.xpathEval("Index")[0].content
    return parseInt(indexstr)

def hasEntryName(node):
    try:
        name= node.xpathEval("Name")[0].content
        subindex = node.xpathEval("SubIndex")[0].content
    except:
        return False
    return True

def getEntryName(node):
    name= node.xpathEval("Name")[0].content
    name= name.replace(" ", "")
    return name

def parseFile(filename, output, list_devices, extraPdos):
    doc = libxml2.parseFile(filename)
    vendor = parseInt(doc.xpathEval("//Vendor/Id")[0].content)
    for device in doc.xpathEval("//Device"):
        try:
            devtype = device.xpathEval("Type")[0].content
            product = parseInt(device.xpathEval("Type/@ProductCode")[0].content)
            revision = parseInt(device.xpathEval("Type/@RevisionNo")[0].content)
        except:
            continue
        # key = (vendor, product, revision)
        key = (devtype, revision)
        if list_devices:
            print "%s 0x%08x (product = 0x%08x)" % (  devtype, revision, product)
            continue

        oversampling = set()
        
        if key in reqs:
            longin = []
            longout = []
            bi = []
            bo = []
            ai = []
            
            for dcmode in device.xpathEval("Dc/OpMode/Sm/Pdo[@OSFac]"):
                oversampling.add(parseInt(dcmode.content))
            for txpdo in device.xpathEval("TxPdo"):
                # pdos without sync manager entries are not default
                if not txpdo.xpathEval("@Sm"):
                    if not (getPdoIndex(txpdo) in extraPdos):
                        continue
                for entry in txpdo.xpathEval("Entry"):
                    # some pdo entries are just padding with no name, ignore
                    if hasEntryName(entry):
                        datatype = entry.xpathEval("DataType")[0].content
                        if datatype == "BOOL":
                            bi.append(getPdoName(txpdo) + "." + getEntryName(entry) )
                        elif datatype == "FLOAT":
                            ai.append(getPdoName(txpdo) + "." + getEntryName(entry) )
                        else:
                            longin.append(getPdoName(txpdo) + "." + getEntryName(entry) )
                    elif verbose:
                        print "Ignoring entry in pdo %s" % getPdoName(txpdo)
            for rxpdo in device.xpathEval("RxPdo"):
                # pdos without sync manager entries are not default
                if not rxpdo.xpathEval("@Sm"):
                    if not (getPdoIndex(rxpdo) in extraPdos):
                        continue
                for entry in rxpdo.xpathEval("Entry"):
                    # some pdo entries are just padding with no name, ignore
                    if hasEntryName(entry):
                        datatype = entry.xpathEval("DataType")[0].content
                        if datatype == "BOOL":
                            bo.append(getPdoName(rxpdo) + "." + getEntryName(entry) )
                        else:
                            longout.append(getPdoName(rxpdo) + "." + getEntryName(entry) )
                    elif verbose:
                        print "Ignoring entry in pdo %s" % getPdoName(txpdo)

            makeTemplate(ai, longin, longout, bi, bo, output, base, devtype, revision, extraPdos)

def usage(progname):
    print "%s: Make EPICS template for EtherCAT device" % progname
    print "Usage:"
    print "   %s -h  Shows this usage message" % progname
    print "   %s -b <xml-base-dir> -l  Lists the devices in the database" % progname
    print """
   %s -b <xml-base-dir> -d <device-type> -r <rev-no> [-p comma-separated-pdo-list] -o output-file
       Generates a template in <output-file> for the given device and revision.
       rev-no must be input as a hex number, e.g. 0x00100000
       Use the -p argument to include additional pdos in the template
       """ % progname

def parsePdoassignments(s):
    if len(s) == 0:
        return []
    assignments = list()
    for pdo_index in s.split(","):
        assignments.append(parseInt(pdo_index))
    return assignments

if __name__ == "__main__":
    import getopt
    devtype = None
    revision = None
    output = None
    list_devices = False
    pdoassignment = ""
    
    try:
        optlist, args = getopt.getopt(sys.argv[1:], 'hlb:d:r:o:vp:',
                    ['help','list','base=','device-type=','rev-no=',
                     'output=','verbose','pdoassignment='])
    except getopt.GetoptError, err:
        print str(err)
        usage(sys.argv[0])
        sys.exit(2)
    for o,a in optlist:
        if o in ('-h', '--help'):
            usage(sys.argv[0])
            sys.exit()
        elif o in ('-l', '--list'):
            list_devices = True
        elif o in ('-b', '--base'):
            base = a
        elif o in ('-d','--device-type'):
            devtype = a
        elif o in ('-r','--rev-no'):
            revision = int(a,16)
        elif o in ('-v','--verbose'):
            verbose = True
        elif o in ('-o','--output'):
            output = a
        elif o in ('-p','--pdoassignment'):
            pdoassignment = a
        else:
            usage(sys.argv[0])
            sys.exit(1)
    if not base:
        print "No base specified"
        usage(sys.argv[0])
        sys.exit(1)
    elif verbose:
        print "base=%s" % base
    if not list_devices:
        if not devtype :
            print "No devtype specified"
            usage(sys.argv[0])
            sys.exit(1)
        elif verbose:
            print "devtype=%s" % devtype
        if  revision == None:
            print "No revision specified"
            usage(sys.argv[0])
            sys.exit(1)
        elif verbose:
            print "revision=%s" % revision
        if not output:
            print "No output specified"
            usage(sys.argv[0])
            sys.exit(1)
        elif verbose:
            print "output=%s" % output

        reqs.add((devtype, revision))
        if verbose:
            for obj in reqs:
                print "Searching device %s, revision 0x%08x" % obj

    assert(list_devices or len(reqs) == 1)
    import os
    for f in os.listdir(base):
        if f.endswith("xml"):
            filename = os.path.join(base, f)
            if verbose:
                print "Parsing %s" % filename
            parseFile(filename, output, list_devices,
                      parsePdoassignments(pdoassignment))


# loads chain description, outputs complete config file...
