Run-time type information
=========================

Ethercat scanner contains run-time type information for each PDO:

static field_t fields[] =
{
    { "ID", offsetof(EK1101_device, regs.ID), sizeof(uint16_t)  },
    { "alarm", offsetof(EK1101_device, self.alarm), sizeof(uint8_t)  },
    { NULL }
};

Process is called to copy the PDO data into a structure:

void EK1101_process(ethercat_device * self, uint8_t * pd)
{
    EK1101_device * dev = (EK1101_device *)self;
    dev->regs.ID = EC_READ_U16(pd + dev->ID);
}

a 'base class' process method is also called which updates the slave metadata (alarm):
this should be tidied up:

{
    dev->alarm = get_slave_info(dev->pos);
}

Read_field copies out the structure member (this could be combined 
with the previous stage, however this also copies non-PDO data like
alarm status):

int ethercat_device_read_field(ethercat_device * self, field_t * f, void * buf, int max_buf)
{
    if(max_buf >= f->size)
    {
        memcpy(buf, (char *)self + f->offset, f->size);
        return f->size;
    }
    return 0;
}

The master device supports the same methods, but process calls non-PDO methods:

void master_device_process(ethercat_device * base, uint8_t * dummy)
{
    master_device * dev = (master_device *)base;
    ecrt_master_state(dev->master, &dev->ms);
    dev->slaves_responding = dev->ms.slaves_responding;
    dev->al_states = dev->ms.al_states;
    dev->link_up = dev->ms.link_up;
}

Probably the PDO data pointer should be stored in the device on initialization
and process should take no parameters

Dispatching Monitors
====================

The client registers monitors with the device with this message:

{ MSG_MONITOR, client, 2,   REASON_CYCLE, "cycle0" },

'client' is the client connection identifier (socket 1, socket 2 etc)

Next is the virtual address of the device in the chain (not the physical position)

Next is the ASYN reason or virtual circuit identifier used for routing on the client

Finally is the name of the variable to monitor which is used in the RTTI field lookup above

The ASYN address of this would be

ASYN(ECAT)2,cycle0

"Port ECAT, virtual address 2, parameter cycle0"

The REASON is generated internally to ASYN


Chain Configuration
===================

Currently each device needs a short driver, 
this is partly generated by the ouput of the 'ethercat cstruct' command.
It is necessary to use this initialization method for all devices, even
simple ones, otherwise the oversampling devices do not work.

The device factory maps names to constructors:

ethercat_constructor device_factory[] = 
{
    {"EL3162", EL3162_init},
    {"EK1101", EK1101_init},
    {"EL4102", EL4102_init},
    {"EL3702", EL3702_init},
    { NULL }
};

The chain configuration file has the format

(device name, virtual address, bus alias, bus position, user string)

The user string is passed to the device constructor and used in this case
to choose 10x oversampling on the EL3702

// chain configuration file

ethercat_device_config chain[] = 
{
    {"EK1101", 100, 0, 0},
    {"EL4102", 200, 0, 1},
    {"EL3702", 300, 0, 2, "10"},
    {"EL3162", 400, 0, 3},
    { NULL }
};

The configuration file no longer contains individual PDO entries, these are configured
by the device constructors using the generated code mentioned above.

The master is given a reserved virtual address:

enum { MASTER_VADDR = 32768 };

Alias
=====

There is a problem here as the master only supports getting slave info by position,
not alias:

int ecrt_master_get_slave(
        ec_master_t *master, /**< EtherCAT master */
        uint16_t slave_position, /**< Slave position. */
        ec_slave_info_t *slave_info /**< Structure that will output the
                                      information */
        );

So it's better not to use the aliases at all.

Chain Config Text File?
=======================

# line length 1024
# hash lines for comments
# device name, vaddr, alias, pos, user string:
EK1101 100 0 0
EL4102 200 0 1
EL3702 300 0 2 10
EL3162 400 0 3

Device Driver Text File
=======================

It should be possible to configure devices using a text file
(oversampling devices may need a bit of code)

It may even be possible to configure devices at startup time, 
as the master scans the bus to generate 'cstruct' anyway

/* Master 0, Slave 1, "EL4102"
 * Vendor ID:       0x00000002
 * Product code:    0x10063052
 * Revision number: 0x03fa0000
 */

ec_pdo_entry_info_t slave_1_pdo_entries[] = {
    {0x3001, 0x01, 16},
    {0x3002, 0x01, 16},
};

ec_pdo_info_t slave_1_pdos[] = {
    {0x1600, 1, slave_1_pdo_entries + 0}, /* RxPDO 01 mapping */
    {0x1601, 1, slave_1_pdo_entries + 1}, /* RxPDO 02 mapping */
};

ec_sync_info_t slave_1_syncs[] = {
    {0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},
    {1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
    {2, EC_DIR_OUTPUT, 2, slave_1_pdos + 0, EC_WD_DISABLE},
    {3, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
    {0xff}
};

Will also need to name each PDO entry, this is detected for EL3702 but not the
other devices, in this case the names are

char * pdo_names[] = {"output0", "output1"};

Also needs to allocate memory instead of using a structure, in this case:

n = 0
size = 0
for e in pdo_entries: 
    offset[n] = size
    size += e.entry_size_bytes * oversampling_factor
    n++

buf = calloc(entry_size_bytes * sizeof(char))

field[0] = {"output0", "output1"}

looks pretty easy actually...

Could also use the XML file for the device from Beckhoff.

Process becomes generic, show becomes generic.

Writing
=======

Currently cheating, using ASYN(ECAT)pos,channel

calls device[pos]->write(channel, value)

Change to ASYN(ECAT)vaddr,name

what is asyn write message?

1) { MSG_WRITE, name, value }

Needs to send string name for each sample, also needs to look up name in scanner each time.

2) scanner_uid = { MSG_LOOKUP, name }

Send only int identifier, fast lookup

{ MSG_WRITE, scanner_uid, value }


Monitors that update on change / monitors that update at a certain rate
=======================================================================

Goes in scanner code:

Ethercat ASYN(ECAT)100,value0,rate(ms)

for waveforms, asyn can't detect the waveform size at initialization time
need to set the buffer size in the ASYN address:

Ethercat ASYN(ECAT)100,value0,rate(ms),nsamples

Disconnect / Reconnect
======================

Reboot scanner without rebooting IOC
====================================

Need to keep list of write mapping and monitor requests


Reboot IOC without rebooting scanner
====================================

This will work


Use IOC as scanner server
=========================

Generate records for each PDO









